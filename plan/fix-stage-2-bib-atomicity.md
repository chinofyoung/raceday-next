# Stage 2 ‚Äî Security: Bib Race Condition & QR Double-Generation
**Priority:** üî¥ Critical
**Issues Fixed:** #2 (Bib Race Condition), #21 (Free Reg QR Generated Twice)
**Files Touched:** 2
**Risk:** Medium ‚Äî changes core payment + bib logic. Test with concurrent registrations.

---

## Overview

Two related issues in the payment + bib generation pipeline:

1. **Race Condition (#2):** Sequential bib numbers are generated by counting existing registrations then adding 1. Two simultaneous webhook calls or payments read the same count ‚Üí same bib number issued to two runners.
2. **Double QR Generation (#21):** Free registrations call `generateBibAndQR` twice ‚Äî once with a fake `"temp-id"` and once with the real Firestore ID ‚Äî wasting Cloudinary uploads and making the first QR code orphaned.

---

## Fix 1 ‚Äî Atomic Bib Number via Firestore Counter Document
**Issue:** #2
**File:** `lib/bibUtils.ts`

### The Problem

```ts
// RACE CONDITION ‚Äî two requests can read size = 5 simultaneously ‚Üí both get "006"
const existingSnap = await getDocs(query(collection(db, "registrations"), ...));
bibNumber = String(existingSnap.size + 1).padStart(3, "0");
```

### The Solution

Use a **dedicated counter document** per `eventId + categoryId` with Firestore's `FieldValue.increment(1)` inside a **transaction**. `increment` is atomic ‚Äî even under concurrent writes, each caller gets a unique number.

### Counter Document Structure

Collection: `bibCounters`
Document ID: `{eventId}_{categoryId}`
Fields: `{ count: number }`

### Updated `lib/bibUtils.ts`

Replace the entire `generateBibNumber` function:

```ts
import { db } from "@/lib/firebase/config";
import {
    doc,
    getDoc,
    runTransaction,
    collection,
    query,
    where,
    getDocs,
} from "firebase/firestore";
import { generateQRCode } from "@/lib/qr";

/**
 * Atomically generates the next sequential bib number for an event+category.
 * Uses a dedicated counter document with Firestore runTransaction to prevent
 * race conditions under concurrent simultaneous payments.
 */
export async function generateBibNumber(
    eventId: string,
    categoryId: string,
    vanityNumber?: string | null
): Promise<string> {
    // 1. Fetch event to read the category's raceNumberFormat
    const eventDoc = await getDoc(doc(db, "events", eventId));
    const eventData = eventDoc.data();
    const category = eventData?.categories?.find(
        (c: any) => (c.id || "0") === categoryId
    );
    const format = category?.raceNumberFormat || "{number}";

    // 2. If vanity number is chosen, skip counter entirely
    if (vanityNumber) {
        return format.replace("{number}", vanityNumber);
    }

    // 3. Atomically increment the counter document
    const counterRef = doc(db, "bibCounters", `${eventId}_${categoryId}`);

    const nextCount = await runTransaction(db, async (transaction) => {
        const counterSnap = await transaction.get(counterRef);

        if (!counterSnap.exists()) {
            // First registration for this event+category ‚Äî initialize at 1
            transaction.set(counterRef, { count: 1 });
            return 1;
        }

        const newCount = (counterSnap.data().count || 0) + 1;
        transaction.update(counterRef, { count: newCount });
        return newCount;
    });

    // 4. Format using the category template
    const paddedNumber = String(nextCount).padStart(3, "0");
    return format.replace("{number}", paddedNumber);
}

/**
 * Generates bib number + QR code data for a registration.
 * Returns both so the caller can store them on the registration doc.
 */
export async function generateBibAndQR(
    registrationId: string,
    eventId: string,
    categoryId: string,
    runnerName: string,
    vanityNumber?: string | null
): Promise<{ raceNumber: string; qrCodeUrl: string }> {
    const raceNumber = await generateBibNumber(eventId, categoryId, vanityNumber);

    const qrData = JSON.stringify({
        registrationId,
        eventId,
        runnerName,
        raceNumber,
    });
    const qrCodeUrl = await generateQRCode(qrData);

    return { raceNumber, qrCodeUrl };
}
```

### Firestore Security Rules

Add a rule to protect `bibCounters` ‚Äî only the server (Admin SDK, or authenticated writes) should modify it. If using the client Firebase SDK in API routes, add this to `firestore.rules`:

```
match /bibCounters/{counterId} {
    // Only allow reads/writes from server-side functions
    // (regular users should never touch this collection)
    allow read, write: if false;
}
```

> ‚ö†Ô∏è If your API routes use the **client** Firebase SDK (current setup), this rule will block it. You have two options:
> - Switch to Firebase Admin SDK in API routes (recommended ‚Äî see Stage 1 for setup)
> - Or use a more permissive rule scoped to authenticated server calls

### Migration Note

Existing events with paid registrations will have their bib counter out of sync with reality (the counter document won't exist yet). Run a one-time migration script to seed counter documents:

**`scripts/seed-bib-counters.ts`** (create this file):
```ts
// Run with: npx ts-node scripts/seed-bib-counters.ts
// Seeds bibCounter documents from existing paid registrations

import { initializeApp } from "firebase/app";
import { getFirestore, collection, getDocs, doc, setDoc, query, where } from "firebase/firestore";
// ... your firebase config

async function seedBibCounters() {
    const regsSnap = await getDocs(
        query(collection(db, "registrations"), where("status", "==", "paid"))
    );

    const counters = new Map<string, number>();

    regsSnap.docs.forEach(d => {
        const { eventId, categoryId } = d.data();
        if (eventId && categoryId) {
            const key = `${eventId}_${categoryId}`;
            counters.set(key, (counters.get(key) || 0) + 1);
        }
    });

    for (const [key, count] of counters) {
        await setDoc(doc(db, "bibCounters", key), { count });
        console.log(`Set ${key} ‚Üí ${count}`);
    }

    console.log(`Seeded ${counters.size} counter documents.`);
}

seedBibCounters().catch(console.error);
```

---

## Fix 2 ‚Äî Free Registration: Generate QR Once
**Issue:** #21
**File:** `app/api/payments/create-checkout/route.ts`

### The Problem

```ts
// CURRENT ‚Äî generates QR twice
const { raceNumber, qrCodeUrl } = await generateBibAndQR(
    "temp-id",   // ‚Üê fake ID, wrong QR data
    ...
);

const regRef = await addDoc(collection(db, "registrations"), {
    ...registrationData, raceNumber, qrCodeUrl, ...
});

// Generate AGAIN with real ID ‚Äî wasteful
const { qrCodeUrl: realQr } = await generateBibAndQR(regRef.id, ...);
await updateDoc(doc(db, "registrations", regRef.id), { qrCodeUrl: realQr });
```

### The Fix

Create the Firestore document first (without a QR), then generate the bib+QR once with the real document ID, then update in a single write.

```ts
// FIXED ‚Äî create doc first, generate QR once
if (totalAmount <= 0) {
    // 1. Create the registration document first (no QR yet)
    const regRef = await addDoc(collection(db, "registrations"), {
        ...registrationData,
        status: "paid",
        paymentStatus: "free",
        paidAt: serverTimestamp(),
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
    });

    // 2. Generate bib + QR with the REAL document ID (one time only)
    const { raceNumber, qrCodeUrl } = await generateBibAndQR(
        regRef.id,                          // ‚Üê real ID now
        registrationData.eventId,
        registrationData.categoryId,
        registrationData.participantInfo.name,
        registrationData.vanityNumber
    );

    // 3. Update with bib + QR in a single write
    await updateDoc(doc(db, "registrations", regRef.id), {
        raceNumber,
        qrCodeUrl,
    });

    return NextResponse.json({
        checkoutUrl: null,
        registrationId: regRef.id,
        free: true,
    });
}
```

---

## Acceptance Criteria

- [ ] Run 10 simultaneous registration completions for the same event+category ‚Äî all get unique bib numbers
- [ ] `bibCounters/{eventId}_{categoryId}` document is created and increments correctly
- [ ] Free registrations create exactly **1** QR code upload to Cloudinary (verify in Cloudinary Media Library)
- [ ] Free registrations have the correct `registrationId` embedded in the QR code data
- [ ] Migration script runs without errors on staging environment
- [ ] Existing paid registrations are unaffected (bib numbers not changed)

---

## Testing Checklist

- [ ] Register for a free event (‚Ç±0 category) ‚Äî verify bib + QR generated correctly
- [ ] Register for a paid event ‚Äî verify bib + QR generated after webhook
- [ ] Simulate two simultaneous paid registrations ‚Äî verify different bib numbers
- [ ] Check Cloudinary ‚Äî free registration should show exactly 1 new asset per registration
